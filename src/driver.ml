module Parse : sig
  val parse : string -> unit
end = struct
  (* Assume these modules are generated by ocamllex and ocamlyacc *)
  module TigerParser = Grammar

  let parse filename =
    let ic = open_in filename in
      let lexbuf = Lexing.from_channel ic in
      ErrorMsg.reset();
      ErrorMsg.fileName := filename;
      let result = TigerParser.program TigerLexer.token lexbuf in
      close_in ic;
      Prabsyn.PrintAbsyn.print (stdout, result)    
end

module TigerParser = Grammar
let token_to_string token =
  match token with
  | TigerParser.WHILE -> "WHILE"
  | TigerParser.FOR -> "FOR"
  | TigerParser.TO -> "TO"
  | TigerParser.BREAK -> "BREAK"
  | TigerParser.LET -> "LET"
  | TigerParser.IN -> "IN"
  | TigerParser.END -> "END"
  | TigerParser.FUNCTION -> "FUNCTION"
  | TigerParser.VAR -> "VAR"
  | TigerParser.TYPE -> "TYPE"
  | TigerParser.ARRAY -> "ARRAY"
  | TigerParser.IF -> "IF"
  | TigerParser.THEN -> "THEN"
  | TigerParser.ELSE -> "ELSE"
  | TigerParser.DO -> "DO"
  | TigerParser.OF -> "OF"
  | TigerParser.NIL -> "NIL"
  | TigerParser.ASSIGN -> "ASSIGN"
  | TigerParser.COMMA -> "COMMA"
  | TigerParser.COLON -> "COLON"
  | TigerParser.SEMICOLON -> "SEMICOLON"
  | TigerParser.DOT -> "DOT"
  | TigerParser.LPAREN -> "LPAREN"
  | TigerParser.RPAREN -> "RPAREN"
  | TigerParser.LBRACE -> "LBRACE"
  | TigerParser.RBRACE -> "RBRACE"
  | TigerParser.LBRACK -> "LBRACK"
  | TigerParser.RBRACK -> "RBRACK"
  | TigerParser.AND -> "AND"
  | TigerParser.OR -> "OR"
  | TigerParser.DIVIDE -> "DIVIDE"
  | TigerParser.TIMES -> "TIMES"
  | TigerParser.PLUS -> "PLUS"
  | TigerParser.MINUS -> "MINUS"
  | TigerParser.NEQ -> "NEQ"
  | TigerParser.LE -> "LE"
  | TigerParser.GE -> "GE"
  | TigerParser.GT -> "GT"
  | TigerParser.LT -> "LT"
  | TigerParser.EQ -> "EQ"
  | TigerParser.ID s -> "ID(" ^ s ^ ")"
  | TigerParser.INT i -> "INT(" ^ string_of_int i ^ ")"
  | TigerParser.STRING s -> "STRING(\"" ^ s ^ "\")"
  | TigerParser.EOF -> "EOF"
let test_lex filename =
    let file = open_in filename in
    let lexbuf = Lexing.from_channel file in
    let rec do_it () =
      let t = TigerLexer.token lexbuf in
      print_endline ((token_to_string t ) ^ "   ");
      if String.length (token_to_string t) = 3 && String.sub (token_to_string t) 0 3 = "EOF" then
        ()
      else
        do_it ()
    in
    do_it ();
    close_in file
    (*
    let typecheck filename = 
      let ic = open_in filename in
      let lexbuf = Lexing.from_channel ic in
      let result = Grammar.program TigerLexer.token lexbuf in
      Semant.transExp Env.base_venv Env.base_tenv result 
      *)